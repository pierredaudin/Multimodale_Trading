/* autogenerated by Processing revision 1290 on 2024-12-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import fr.dgac.ivy.*;
import fr.dgac.ivy.tools.*;
import gnu.getopt.*;

import fr.dgac.ivy.*;
import javax.swing.JOptionPane;
import java.util.ArrayList;
import java.io.*;
import java.util.Stack;
import java.util.StringTokenizer;
import java.io.Serializable;
import java.util.Stack;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class OneDollarIvy extends PApplet {





// Déclaration des variables principales
Ivy bus;
Recognizer recognizer;
Recorder recorder;
Result result;

// Machine à états
FSMState currentState;
String s_result = "";
String recognizedShape = ""; // Forme reconnue par le $1 Recognizer
int currentColor = color(0, 0, 0); // Couleur par défaut : noir
String lastVoiceCommand = "";

// Liste pour mémoriser les formes dessinées
ArrayList<DynamicShape > dynamicShapes = new ArrayList<>();

// Variables pour le $1 Recognizer
int NumTemplates = 16;
int NumPoints = 64;
float SquareSize = 250.0f;
float HalfDiagonal = 0.5f * sqrt(250.0f * 250.0f + 250.0f * 250.0f);
float AngleRange = 45.0f;
float AnglePrecision = 2.0f;
float Phi = 0.5f * (-1.0f + sqrt(5.0f)); // Golden Ratio

// Données pour le graphique de trading
float[] openPrices, closePrices, highPrices, lowPrices;
float candleWidth = 10;
int numCandles = 80; // Nombre de bougies affichées
int frameCounter = 0; // Pour ralentir le défilement du graphique
float priceCenter = 300; // Point de référence pour générer les prix
boolean freezeGraph = false; // Indique si le graphique doit être bloqué


// Coordonnées des points
float startX = -1, startY = -1, endX = -1, endY = -1;

// États possibles
enum FSMState {
  INIT,
  SHAPE_DETECTION,
  WAIT_POINTS,
  DRAW_SHAPE,
  WAIT_FIRST_POINT,
  WAIT_SECOND_POINT
}

// Classe pour représenter une forme
class DynamicShape {
  String type;
  float x1, y1, x2, y2; // Coordonnées relatives au graphique
  int shapeColor;

  DynamicShape(String type, float x1, float y1, float x2, float y2, int shapeColor) {
    this.type = type;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.shapeColor = shapeColor;
  }

  public void updatePosition(float offsetX) {
    x1 -= offsetX;
    x2 -= offsetX;
  }

  public void display() {
    stroke(shapeColor);
    if (type.equals("ligne")) {
      line(x1, y1, x2, y2);
    } else if (type.equals("rectangle")) {
      // Tracer les quatre lignes du rectangle
      line(x1, y1, x2, y1); // Ligne supérieure
      line(x1, y2, x2, y2); // Ligne inférieure
      line(x1, y1, x1, y2); // Ligne gauche
      line(x2, y1, x2, y2); // Ligne droite
    }
  }
}


public void setup() {
  /* size commented out by preprocessor */;
  currentState = FSMState.INIT;
  
  // Initialisation des données du graphique
  initializePrices();

  // Initialisation du $1 Recognizer
  recognizer = new Recognizer();
  recorder = new Recorder();
  
  recognizer.Import();

  // Initialisation du bus Ivy
  try {
    bus = new Ivy("OneDollarIvy", "OneDollarIvy is ready", null);
    bus.start("127.255.255.255:2010");

    // Gestion des commandes vocales
    bus.bindMsg("^sra5 Text=(.*) Confidence=.*", new IvyMessageListener() {
      public void receive(IvyClient client, String[] args) {
        lastVoiceCommand = args[0].toLowerCase();
        println("Commande vocale reçue : " + lastVoiceCommand); // Log pour débogage
        handleVoiceCommand(lastVoiceCommand);
      }
    });
  } catch (IvyException ie) {
    println("Erreur de connexion au bus Ivy : " + ie);
  }
}

public void draw() {
  background(40);
  textSize(18);
  fill(0);
  textAlign(CENTER);
  
  // Dessin du graphique (en arrière-plan)
  if (freezeGraph) {
    drawStaticTradingChart();
  } else {
    drawTradingChart();
  }

  // Afficher les formes mémorisées
  for (DynamicShape  shape : dynamicShapes) {
    shape.display();
  }

  // Afficher l'état et la commande vocale
  fill(255);
  text("État actuel : " + currentState, width / 2, 30);
  text("Dernière commande vocale : " + lastVoiceCommand, width / 2, 550);

  switch (currentState) {
    case INIT:
      fill(255);
      text("Dites 'créer une forme' ou 'dessine une forme' pour commencer.", width / 2, height / 2);
      break;

    case SHAPE_DETECTION:
      fill(255);
      text("Tracez une forme pour la reconnaissance.", width / 2, height / 2);
      recorder.update();
      recorder.draw();

      if (recorder.hasPoints) {
        Point[] points = recorder.points;
        result = recognizer.Recognize(points);
        recorder.hasPoints = false;
      }

      if (result != null) {
        recognizedShape = result.Name; // Forme reconnue
        if (!recognizedShape.isEmpty() && !recognizedShape.equals("NONE")) {
          println("Forme reconnue : " + recognizedShape);
          currentState = FSMState.WAIT_FIRST_POINT;
        } else {
          println("Forme non reconnue, veuillez réessayer.");
        }
        result = null; // Réinitialiser
      }
      break;

    case WAIT_FIRST_POINT:
      freezeGraph = true; // Bloquer le graphique
      fill(255);
      text("Dites 'd'ici' pour définir le premier point.", width / 2, height / 2);
      break;

    case WAIT_SECOND_POINT:
    fill(255);
      text("Dites 'à là' pour définir le deuxième point.", width / 2, height / 2);
      break;

    case DRAW_SHAPE:
      if (isValidPoints(startX, startY, endX, endY)) {
        // Ajouter la forme dynamique liée au graphique
        dynamicShapes.add(new DynamicShape(recognizedShape, startX, startY, endX, endY, currentColor));
        println("Forme ajoutée et attachée au graphique : " + recognizedShape);
      } else {
        println("Points invalides, opération annulée.");
      }
      freezeGraph = false; // Débloquer le graphique
      resetState();
      break;
  }
}

public void handleVoiceCommand(String command) {
  if (command.contains("rouge")) currentColor = color(255, 0, 0);
  else if (command.contains("vert")) currentColor = color(0, 255, 0);
  else if (command.contains("bleu")) currentColor = color(0, 0, 255);
  else if (command.contains("jaune")) currentColor = color(255, 255, 0);
  else if (command.contains("noir")) currentColor = color(0, 0, 0);
  else if (command.contains("blanc")) currentColor = color(255, 255, 255);

  if (command.contains("créer") || command.contains("dessine")) {
    println("Commande reconnue : Créer une forme.");
    currentState = FSMState.SHAPE_DETECTION;
  } else if ((command.contains("d'ici") || command.contains("de ici")) && currentState == FSMState.WAIT_FIRST_POINT) {
    startX = mouseX;
    startY = mouseY;
    println("Premier point défini à (" + startX + ", " + startY + ")");
    currentState = FSMState.WAIT_SECOND_POINT;
  } else if (command.contains("à là") && currentState == FSMState.WAIT_SECOND_POINT) {
    endX = mouseX;
    endY = mouseY;
    println("Deuxième point défini à (" + endX + ", " + endY + ")");
    currentState = FSMState.DRAW_SHAPE;
  }
}

public boolean isValidPoints(float x1, float y1, float x2, float y2) {
  return x1 >= 0 && y1 >= 0 && x2 >= 0 && y2 >= 0;
}

public void resetState() {
  startX = -1;
  startY = -1;
  endX = -1;
  endY = -1;
  recognizedShape = "";
  currentState = FSMState.INIT;
}

// Initialisation des données pour le graphique
public void initializePrices() {
  openPrices = new float[numCandles];
  closePrices = new float[numCandles];
  highPrices = new float[numCandles];
  lowPrices = new float[numCandles];

  float price = priceCenter;
  for (int i = 0; i < numCandles; i++) {
    float open = price + random(-20, 20);
    float close = open + random(-20, 20);
    float high = max(open, close) + random(5, 10);
    float low = min(open, close) - random(5, 10);

    openPrices[i] = open;
    closePrices[i] = close;
    highPrices[i] = high;
    lowPrices[i] = low;
    price = close;
  }
}

// Dessiner le graphique
public void drawTradingChart() {
  frameCounter++;
  if (frameCounter % 60 == 0) {
    shiftPrices();
    frameCounter = 0;
  }

  for (int i = 0; i < numCandles; i++) {
    float x = i * candleWidth;
    float open = openPrices[i];
    float close = closePrices[i];
    float high = highPrices[i];
    float low = lowPrices[i];

    stroke(150);
    line(x + candleWidth / 2, height - high, x + candleWidth / 2, height - low);

    if (close > open) fill(0, 255, 0);
    else fill(255, 0, 0);

    noStroke();
    rect(x, height - max(open, close), candleWidth - 2, abs(open - close));
  }
}

// Déplacer les prix pour simuler un défilement
public void shiftPrices() {
  for (int i = 0; i < numCandles - 1; i++) {
    openPrices[i] = openPrices[i + 1];
    closePrices[i] = closePrices[i + 1];
    highPrices[i] = highPrices[i + 1];
    lowPrices[i] = lowPrices[i + 1];
  }

  float open = closePrices[numCandles - 2] + random(-20, 20);
  float close = open + random(-20, 20);
  float high = max(open, close) + random(5, 10);
  float low = min(open, close) - random(5, 10);

  openPrices[numCandles - 1] = open;
  closePrices[numCandles - 1] = close;
  highPrices[numCandles - 1] = high;
  lowPrices[numCandles - 1] = low;

  for (DynamicShape shape : dynamicShapes) {
    shape.updatePosition(candleWidth);
  }
}

// Dessiner le graphique sans le faire défiler
public void drawStaticTradingChart() {
  for (int i = 0; i < numCandles; i++) {
    float x = i * candleWidth;
    float open = openPrices[i];
    float close = closePrices[i];
    float high = highPrices[i];
    float low = lowPrices[i];

    stroke(150);
    line(x + candleWidth / 2, height - high, x + candleWidth / 2, height - low);

    if (close > open) fill(0, 255, 0);
    else fill(255, 0, 0);

    noStroke();
    rect(x, height - max(open, close), candleWidth - 2, abs(open - close));
  }
}
/*
 * Enumération de a Machine à Etats (Finite State Machine)
 *
 */
 
public enum FSM {
  INITIAL, /* Etat Initial */ 
  RECOGNITION, /* mode de reconnaissance */ 
  LEARNING, /* mode apprentissage */
  EXPORT, /* export des templates */
  IMPORT, /* import des templates */ 
  TEMPLATES, /* affichage des templates */ 
  HELP
}
/*
 * Définition d'un Point - et méthodes associées
 */ 
 
class Point {
  float X;
  float Y;
  
  Point(float x, float y) {
    X = x;
    Y = y;
  }

  public float distance(Point other) {
    return dist(X, Y, other.X, other.Y);
  }
}
/*
 * Recognizer - définition des templates
 */

 
 
  


class Recognizer {
  float Infinity = 1e9f; 
  Template [] Templates = {};
  
   Recognizer() {
     // nothing to do
   }

  /* ===================================================== */
  public Result Recognize(Point [] points) {
    points = Resample(points, NumPoints);
    points = RotateToZero(points);
    points = ScaleToSquare(points, SquareSize);
    points = TranslateToOrigin(points);
    float best = Infinity;
    float sndBest = Infinity;
    int t = -1;
    for( int i = 0; i < Templates.length; i++) {
      float d = DistanceAtBestAngle(points, Templates[i], -AngleRange, AngleRange, AnglePrecision);
      if( d < best ) {
        sndBest = best;
        best = d;
        t = i;
      }
      else if( d < sndBest) {
        sndBest = d;
      }
    }
    float score = 1.0f - (best / HalfDiagonal);
    float otherScore = 1.0f - (sndBest / HalfDiagonal);
    float ratio = otherScore / score;
    // The threshold of 0.7 is arbitrary, and not part of the original code.
    if( t > -1 && score > 0.7f) {
      return new Result( Templates[t].Name, score, ratio );
    }
    else {
      return new Result( "NONE", 0.0f, 1.0f);
    }
  }

  public int AddTemplate( String name, Point [] points) {
    Templates = (Template []) append( Templates, new Template(name, points));
    int num = 0;
    for( int i = 0; i < Templates.length; i++) {
      if( Templates[ i ].Name == name) {
        num++;
      }
    }
    return num;
  }

  public void DeleteUserTemplates( ) {
    Templates = (Template [])subset(Templates, 0, NumTemplates);
  }

  /* ---------------------------------- */
  public Point [] Resample( Point [] points, int n) {
    float I = PathLength( points ) / ( (float)n -1.0f );
    float D = 0.0f;
    Point [] newpoints = {};
    Stack stack = new Stack();
    for( int i = 0; i < points.length; i++) {
      stack.push( points[ points.length -1 - i]);
    }
    
   while( !stack.empty()) {
     Point pt1 = (Point) stack.pop();
     if( stack.empty()) {
       newpoints = (Point [])append( newpoints, pt1);
       continue;
     }
     Point pt2 = (Point) stack.peek();
     float d = pt1.distance( pt2);
     if( (D + d) >= I) {
       float qx = pt1.X + (( I - D ) / d ) * (pt2.X - pt1.X);
       float qy = pt1.Y + (( I - D ) / d ) * (pt2.Y - pt1.Y);
       Point q = new Point( qx, qy);
       newpoints = (Point [])append( newpoints, q);
       stack.push( q );
       D = 0.0f;
     } 
     else {
       D += d;
     }
   }
   if (newpoints.length == (n -1)) {
     newpoints = (Point [])append(newpoints, points[points.length -1]);
   }
   return newpoints;
  }
 
 
  public Point [] RotateToZero(Point [] points) {
    Point c = Centroid(points);
    float theta = atan2( c.Y - points[0].Y, c.X - points[0].X);
    return RotateBy( points, -theta);
  }

  public Point [] ScaleToSquare( Point [] points, float sz) {
    Rectangle B = BoundingBox( points );
    Point [] newpoints = {};
    for( int i = 0; i < points.length; i++) {
      float qx = points[i].X * (sz / B.Width);
      float qy = points[i].Y * (sz / B.Height);
      newpoints = (Point [])append( newpoints,  new Point(qx, qy));
    }
    return newpoints;
  }

 public Point [] TranslateToOrigin(Point [] points) {
   Point c = Centroid(points);
   Point [] newpoints = {};
   for( int i = -0; i < points.length; i++) {
     float qx = points[i].X - c.X;
     float qy = points[i].Y - c.Y;
     newpoints = (Point [])append(newpoints,  new Point(qx, qy));
   }
   return newpoints;
  }
  
  public Point [] RotateBy( Point [] points, float theta) {
    Point c = Centroid( points );
    float Cos = cos( theta );
    float Sin = sin( theta );
    Point [] newpoints = {};
    for( int i = 0; i < points.length; i++) {
      float qx = (points[i].X - c.X) * Cos - (points[i].Y - c.Y) * Sin + c.X;
      float qy = (points[i].X - c.X) * Sin + (points[i].Y - c.Y) * Cos + c.Y;
      newpoints = (Point[]) append(newpoints, new Point( qx, qy ));
   }
   return newpoints;
  }

  public float DistanceAtAngle( Point [] points, Template T, float theta) {
    Point [] newpoints = RotateBy( points, theta);
    return PathDistance( newpoints, T.Points);
  }  
  
  public float DistanceAtBestAngle( Point [] points, Template T, float a, float b, float threshold) {
   float x1 = Phi * a + (1.0f - Phi) * b;
   float f1 = DistanceAtAngle(points, T, x1);
   float x2 = (1.0f - Phi) * a + Phi * b;
   float f2 = DistanceAtAngle(points, T, x2);
   while( abs( b - a ) > threshold) {
     if( f1 < f2 ) {
       b = x2;
       x2 = x1;
       f2 = f1;
       x1 = Phi * a + (1.0f - Phi) * b;
       f1 = DistanceAtAngle(points, T, x1);
     }
     else {
       a = x1;
       x1 = x2;
       f1 = f2;
       x2 = (1.0f - Phi) * a + Phi * b;
       f2 = DistanceAtAngle(points, T, x2);
     }
   }
   return min(f1, f2);
  }
  
   
  public float PathLength( Point [] points) {
    float d = 0.0f;
    for( int i = 1; i < points.length; i++) {
      d += points[i-1].distance( points[i]);
    }
    return d;
  }


  public float PathDistance( Point [] pts1, Point [] pts2) {
    if( pts1.length != pts2.length) {
      // println( "Lengths differ. " + pts1.length + " != " + pts2.length);
      return Infinity;
    }
    float d = 0.0f;
    for( int i = 0; i < pts1.length; i++) {
      d += pts1[i].distance( pts2[i]);
    }
    return d / (float)pts1.length;
  }


  public Rectangle BoundingBox( Point [] points) {
    float minX = Infinity;
    float maxX = -Infinity;
    float minY = Infinity;
    float maxY = -Infinity;

    for( int i = 1; i < points.length; i++) {
      minX = min( points[i].X, minX);
      maxX = max( points[i].X, maxX);
      minY = min( points[i].Y, minY);
      maxY = max( points[i].Y, maxY);
    }
    return new Rectangle( minX, minY, maxX - minX, maxY - minY);
  }


  public Point Centroid( Point [] points) {
    Point centriod = new Point(0.0f, 0.0f);
    for( int i = 1; i < points.length; i++) {
      centriod.X += points[i].X;
      centriod.Y += points[i].Y;
    }
    centriod.X /= points.length;
    centriod.Y /= points.length;
    return centriod;
  }  
  
  public void Export() { // Export templates
    FileOutputStream fos;    
    // Pour chaque template, sauver le nom et l'ensemble des points dans un fichier .dat
    // détruire les fichiers auparavant
    for (int i=0;i < Templates.length; i++) {
      try {
         fos = new FileOutputStream(dataPath("") + "/templates/" + Templates[i].Name + ".dat");
         DataOutputStream dos = new DataOutputStream(fos);
         for (int j=0;j<Templates[i].Points.length;j++) {
           dos.writeFloat(Templates[i].Points[j].X);
           dos.writeFloat(Templates[i].Points[j].Y);
         }
         fos.close();
      }
      catch (Exception e) {}
    }
  }
  
  public void Import() { // import templates
    // importer les templates
    // détruire ceux préalblement existants
    Templates = new Template[0];
    
    FileInputStream fis;
    // lister les .template dans le répertoire /templates 
    // charger les fichiers et les sauver comme template   
    try {
      File dir=new File(dataPath("") + "/templates");
      File[] liste=dir.listFiles();
      for (File item:liste) {
        if (item.isFile()) {
          StringTokenizer st = new StringTokenizer(item.getName(),".");
          String filename = st.nextToken();
          // println(">> Nom : " + filename);          
          fis = new FileInputStream(dataPath("") + "/templates/" + item.getName()); 
          DataInputStream dis = new DataInputStream(fis);
          Point[] points = new Point[0];
          // .dat -> 64 Points
          float x,y;
          for (int i=0;i<64;i++) {
            x = dis.readFloat();
            y = dis.readFloat();
            points = (Point[])append(points, new Point(x, y));
          }
          fis.close();
          this.AddTemplate(filename, points);
        }   
      } 
    }
    catch (Exception e) {
      // println(">> ERROR <<");  
    }
  }
  
  public String[] getTemplatesName() {
    String[] names = {}; 
    for (int i=0;i<Templates.length;i++)
       names = (String[])(append(names, Templates[i].Name)); 
    return (names);
  }
}
/*
 * Simple class to record Points
 *
 */
 


class Recorder implements Serializable {
  Point [] points;
  boolean recording;
  boolean hasPoints;

  Recorder() {
     points = new Point[0];
     recording = false;
  }

  public void update() {
    if (recording) {
      if (mousePressed) {
        points = (Point[])append(points, new Point(mouseX, mouseY));
      }
      else {
        recording = false;
        if( points.length > 5) {
          hasPoints = true;
        }
      }
    }
    else {
      if(mousePressed) {
        points = new Point[0];
        recording = true;
        hasPoints = false;
      }
    }
  }

  public void draw( ) {
     int c = color(0,0,0); // Dark
     if(recording) {
       c = color(7, 128, 237); // Blue
     }
     if(points.length > 1) {
       for( int i = 1; i < points.length; i++) {
         stroke(c);
         line( points[i-1].X, points[i-1].Y,
               points[i].X, points[i  ].Y);
       }
     }
  }
}
/*
 * Rectangle to store the bounding box
 *
 */
class Rectangle {
  float X;
  float Y;
  float Width;
  float Height;
  
  Rectangle(float x, float y, float width, float height) {
    X = x;
    Y = y;
    Width = width;
    Height = height;
  }
}
/*
 * Simple class to store results
 *
 */
class Result {
  String Name;
  float Score;
  float Ratio;
  
  Result( String name, float score, float ratio) {
    Name = name;
    Score = score;
    Ratio = ratio;
  }
}
/* A template holds a name and a set of reduced points that represent
 * a single gesture.
 */
 
 

class Template {
  String Name;
  Point [] Points;
  float Infinity = 1e9f; 
  
  Template( String name, Point [] points) {
    Name = name;
    Points = Resample( points, NumPoints);
    Points = RotateToZero( Points );
    Points = ScaleToSquare( Points, SquareSize);
    Points = TranslateToOrigin( Points );
  }
  
  public Point [] Resample( Point [] points, int n) {
   float I = PathLength( points ) / ( (float)n -1.0f );
   float D = 0.0f;
   Point [] newpoints = {};
   Stack stack = new Stack();
   for( int i = 0; i < points.length; i++) {
     stack.push( points[ points.length -1 - i]);
   }

   while( !stack.empty()) {
       Point pt1 = (Point) stack.pop();

       if( stack.empty()) {
         newpoints = (Point [])append( newpoints, pt1);
         continue;
       }
       Point pt2 = (Point) stack.peek();
       float d = pt1.distance( pt2);
       if( (D + d) >= I) {
          float qx = pt1.X + (( I - D ) / d ) * (pt2.X - pt1.X);
          float qy = pt1.Y + (( I - D ) / d ) * (pt2.Y - pt1.Y);
          Point q = new Point( qx, qy);
          newpoints = (Point [])append( newpoints, q);
          stack.push( q );
          D = 0.0f;
       }
       else {
         D += d;
       }
   }

   if(newpoints.length == (n -1)) {
     newpoints = (Point [])append( newpoints, points[ points.length -1 ]);
   }
   return newpoints;
  }
  
  public float PathLength( Point [] points) {
    float d = 0.0f;
    for( int i = 1; i < points.length; i++) {
      d += points[i-1].distance( points[i]);
    }
    return d;
  }
  
  public Point [] RotateToZero(Point [] points) {
   Point c = Centroid(points);
   float theta = atan2( c.Y - points[0].Y, c.X - points[0].X);
   return RotateBy( points, -theta);
  }
  
  public Point [] RotateBy( Point [] points, float theta) {
   Point c = Centroid( points );
   float Cos = cos( theta );
   float Sin = sin( theta );

   Point [] newpoints = {};
   for( int i = 0; i < points.length; i++) {
     float qx = (points[i].X - c.X) * Cos - (points[i].Y - c.Y) * Sin + c.X;
     float qy = (points[i].X - c.X) * Sin + (points[i].Y - c.Y) * Cos + c.Y;
     newpoints = (Point[]) append(newpoints, new Point( qx, qy ));
   }
   return newpoints;
  }
  
  public Point Centroid( Point [] points) {
    Point centriod = new Point(0.0f, 0.0f);
    for( int i = 1; i < points.length; i++) {
      centriod.X += points[i].X;
      centriod.Y += points[i].Y;
    }
    centriod.X /= points.length;
    centriod.Y /= points.length;
    return centriod;
  }
  
  public Point [] ScaleToSquare( Point [] points, float sz) {
    Rectangle B = BoundingBox( points );
    Point [] newpoints = {};
    for( int i = 0; i < points.length; i++) {
       float qx = points[i].X * (sz / B.Width);
       float qy = points[i].Y * (sz / B.Height);
       newpoints = (Point [])append( newpoints,  new Point(qx, qy));
    }
    return newpoints;
  }
  
  public Rectangle BoundingBox( Point [] points) {
    float minX = Infinity;
    float maxX = -Infinity;
    float minY = Infinity;
    float maxY = -Infinity;

    for( int i = 1; i < points.length; i++) {
      minX = min( points[i].X, minX);
      maxX = max( points[i].X, maxX);
      minY = min( points[i].Y, minY);
      maxY = max( points[i].Y, maxY);
    }
    return new Rectangle( minX, minY, maxX - minX, maxY - minY);
  }
  
  public Point [] TranslateToOrigin( Point [] points) {
    Point c = Centroid( points);
    Point [] newpoints = {};
    for( int i = -0; i < points.length; i++) {
      float qx = points[i].X - c.X;
      float qy = points[i].Y - c.Y;
      newpoints = (Point [])append( newpoints,  new Point(qx, qy));
     }
   return newpoints;
  }  
}


  public void settings() { size(800, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "OneDollarIvy" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
